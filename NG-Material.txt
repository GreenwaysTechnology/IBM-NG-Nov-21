

Why Java script was created?

For Web

-is it to create web apps using html.
  No
-To modify the html document inside web browser.


            					DOM 
				 (Document Object Model)

DOM: 
   DOM is spec , defined by W3C to reprenent html elements inside javascript engine.


HTML internal work flow:
........................


...........................................................................................
					compile time
index.html -source code

<html>
<head></head>
<title><title>
<body>
  <div>
     <h1>Welcome</h1>
  </div>
</body>
</html>
   |
------- Loaded into browser using http protocal or ftp or local disk protocal
   |
 Parser  => generates a parsed lexical tree
   |
html
  head
 title
body
  div
     h1 Welcome h1
  div
 body
   html
  |
.......................................................
 compiler  =>generates assembly instruction

html -0AbcA
  head -load head
 title
body
  div
     h1 Welcome h1
  div
 body
   html
--------------------------------------------------------------------------------------------
   |				   Runtime
   |
 runtime ===> will allocate memory on RAM. 

Linked List will be created

html - Node
  head -Node
 title -Node
body - Node
  div - Node
     h1 Welcome h1
  div
 body
   html


Tree will be created -Nodes are linked in hierachical order - parent-child arch

html - Node
  |
  head -Node
   |
 title -Node
   |
body - Node
  |
  div - Node
    |
     h1 Welcome h1
  div
   |
 body
    |
   html
---------
   |
Paint Engine /Layout Engine
  |
Nodes are converted into pixels and drawn on the screen - OUTPUT
---------------------------------------------------------------------------------------------  
Birth of Javascript:
...................

At Netscap decided to modifiy the linked list / tree via special program 

netscap decided to create very light weight programming language to access the tree and modify the tree at runtime - js
............................................................................................
					HTML Elements
.............................................................................................


HTML Elements types

1.built in elements

2.custom elements


HTML Elements types

1.built in elements

2.custom elements
HTML Elements types

1.built in elements

2.custom elements



1.built in elements
  are part of html language spec
 h1,body,p,nav,div

compiler design

 source code
                              compiler db -[div]
                                 |
  <div></div> ----- compile----compiler
                                  |
                      ------------------------
                    if present             
                      |
                    execution
                      |
                     node
                       |
                     screen


                                compiler db -[Subramanian]
                                    |
  <subramanian></subramaian> ----- compile----compiler
                                  |
                      ------------------------
                    if present            if not present           
                      |                        |
                    execution              throw error - UnKnown Element
                      |                                 |
                     node                              Convert that element into PlainText   
                       |                               |
                     screen                           render



2.IN 2007-2008 W3C Decided to introduce new html spec - html 5

 -custom elements - how to add new elements
 -custom attributes - how to add custom attribues on existing html specs

Custom Types
int,float =  class A{ int,float }

how to teach browser to understand custom elements and attributes
   -via Javascript


                             compiler db -[Subramanian]
                                    |
 <subramanian></subramaian> ----- compile----compiler
                                  |
                      ------------------------
                    if present            if not present           
                      |                        |
                    execution              feed into js 
                      |                                 |
                     node                              js will do something   
                       |                               |
                     screen                           render



eg:

class AppDrawer extends HTMLElement {...}

window.customElements.define('app-drawer', AppDrawer);

// Or use an anonymous class if you don't want a named constructor in current scope.
window.customElements.define('app-drawer', class extends HTMLElement {...});



  			              compiler db -[div,Subramanian]
                                           |
<subramanian></subramaian> --jsengine will add new defintion--- compile----compiler
                                   |
                      ------------------------
                    if present            if not present           
                      |                        |
                    execution              throw error - UnKnown Element
                      |                                 |
                     node                              Convert that element into PlanText   
                       |                               |
                     screen                           render

////////////////////////////////////////////////////////////////////////////////////////////
Angular and Custom Elements:

 Angular follows custom element spec in order to create apps.


  Custom Element
  <app-root></app-root>
                  |
                  ------------->|import { Component } from '@angular/core';

				@Component({
 				 selector: 'app-root',
  				templateUrl: './app.component.html',
  				styleUrls: ['./app.component.css']
				})
				export class AppComponent {
					  title = 'ng-helloworld';
				}


<app-root></app-root> ---------------function AppComponent(){ 
                                           //dom code
                                     }


/////////////////////////////////////////////////////////////////////////////////////////////
					Angular Code Part
.............................................................................................

Angular is collection of many projects.

-angular cli

Angular cli :

npm install -g @angular/cli


ng new getting-started

cd getting-started

ng serve
.............................................................................................

Angular is DOM Framework, we create dom objects,modify dom objects via Typescript(javascript).

Component:
  It is one of infra Object.
  It represents DOM objects(HTML elmements)

In Angular no infra object is created by developer rather angular uses ioc /dependency injector- objects are created by the framework and avaialble for us to use.

In Angular all infra object features are injected via "Decorators".

How to create Object ?

-We need class.

class MyClass {

}

let mycls = new MyClass(); =>This step we dont do in angular, angular takes care of that.


How to create Compoent ?

@Component({})
class MyClass {

}

Now Myclass is not normal class, rather which is component class.

Decorators and Infra Objects:
.............................
1.module   ---@NgModule
2.component---@Component
3.service --@Injectable
4.directive -@Directive
5.pipes -@Pipe
.............................................................................................
					Angular App Structure
..............................................................................................

Angular App is collection of many objects.

Angular provides container object called "Module" Object.


Modules:
   Organzation of code.

Types of Modules in angular.

1.Physical module(ES 6 modules)
   
   Separation of code into files and folders

src/app/customer/customer.component.ts

export class Customer {}


import {Customer} from './app/customer/customer.component'


2.Logical modules(Object organzation)
    
    organization of objects(c,directives) at runtime based on features
 we call ngModules
 

Every angular application must have one single container object called "AppModule"


//////////////////////////////////////////////////////////////////////////////////////////////
				   Dependency Injection
............................................................................................

Angular Creates objects automatically , we dont need to create them.

How angular understand that , object need to be created. 

Thats where configuration comes into picture.


Angular defines three types of objects for DI:
..............................................

1.View Objects
   Component,Directive,Pipe
2.SubModules
   @NgModule
3.Services
   @Injectable
.............................................................................................
					Angular MVC Architecture
.............................................................................................

M - model - domain objects
V - View - dom elements -  html elements
C- Controller - Component

Component:

 Object to represent "View" in app

Every angular app must have one Component - Root Component -Main Compoent -Main Page-App Component. - Landing Page


How to create Component?

Component consist of following things?

1.template
    collection of angular instructions

Angular instructions:
1.1. html elements - div,p,span
1.2. data binding symbols -special instructions
     *,[],(),#,directives <>,pipes(|)

2.css
   style sheet
3.code
   logic written in typescript 
 variables,methods,interfaces



How to create Component?

Component consist of following things?

1.template
    collection of angular instructions

Angular instructions:
1.1. html elements - div,p,span
1.2. data binding symbols -special instructions
     *,[],(),#,directives <>,pipes(|)

2.css
   style sheet
3.code
   logic written in typescript 
 variables,methods,interfaces

Comonent has follwing things?

 -dependency
     -services

Steps:

1.declare component class and export it.

export class AppComponent {

}

2.decorate component class. -@Component
Decorator that marks a class as an Angular component and provides configuration metadata that determines how the component should be processed, instantiated, and used at runtime.

3.meta Object {}
@Component({})

@Component({})
export class AppComponent {

}

4.provide meta information
 selector - custom element name
 template - instructions
 css - styles for component



Types of templates:

1.inline template
   template is part of component itself , provided within string
  template: `
           <div>
             <h1>HR Block Angular Apps welcomes you</h1>
           </div>
  `
2.external template
   template is outside component and provided via a separate .html file
templateUrl: './app.component.html',

import { Component } from "@angular/core";

@Component({
  selector: 'app-root',
  templateUrl:'./app.component.html'
})
export class AppComponent {

}
//////////////////////////////////////////////////////////////////////////////////////////////
				   Dependency Injection
............................................................................................

Angular Creates objects automatically , we dont need to create them.

How angular understand that , object need to be created. 

Thats where configuration comes into picture.


//AppModule - to have other objects
// contains injector configuration to create object

import { NgModule } from "@angular/core";
import { BrowserModule } from "@angular/platform-browser";
import { AppComponent } from "./app.component";



@NgModule({
  declarations: [AppComponent], //view objects - Component,Directive,Pipes
  imports: [BrowserModule], //submodules -from angular or custom sub modules
  providers: [], // services,
  bootstrap: [AppComponent]
})
export class AppModule { }
.............................................................................................
				Component driven architecture
............................................................................................

 Angular apps are collection of components.
 Component represent "custom html element"
 custom html element may compose other custom element and htmls elements- hi
 you need to design app based on html hierachical design

  <parent>         ----------------------------Appcomponent -selector
      <child-1>  ------------------------------Child1Component
              <sub-child></sub-child>
      </child-1>
      <child-2> -sibling
		<sub-child>
			...
		</sub-child>
      <child-2>
  </parent>


 <div>
    <div>
        <div></div>
    </div>
 <div>

<app-root>
  <app-header>
        ....
   </app-header>

  <app-body>
        ....
  </app-body>

  <app-footer>

 </app-footer>
 </app-root>
..............................................................................................

Task : 
 -create header /body /footer component
 
Angular coding best pratices:
...............................
https://angular.io/guide/styleguide


file name:
recommended
 header.component.ts
not recommended
 headercomponent.ts
 hcmp.ts

component:
 ts file
 html file
 css file
 spec file

header.component.ts
header.component.html
header.component.css
header.component.spec.ts

style guide for file names

domainname.component|service|directive|pipe.ts
hero.component.ts
hero.service.ts
hero.directive.ts
hero.pipe.ts


Custom elements Naming convention:Component selectors

 <app-root> - recommended
  
 <approot>  - not recommended.

Do use dashed-case or kebab-case for naming the element selectors of components.

............................................................................................

class Names:

 1.Noun
 2.should be meaningfull
 3.should have suffix component,service,directive,pipe

 HeaderComponent
 HeaderService
 HeaderDirective
 HeaderPipe
..............................................................................................
Steps to create Component

1.declare componenent class
2.declare component html 
3.write component logic
4.dependency injection inside moudle
5.refer the compoent inside template.
...........................................................................................
Style guide to create components or any objects

1.modularazation

-physical modularity 
   folders
     files

src
  app
   |
   header
     header files
   footer
     footer files
   body 
    body files

-logical modularity 
    object grouping
 sub modules
   header module 


Style guide to create components or any objects

1.modularazation

-physical modularity 
   folders
     files

src
  app
   |
   header
     header files
   footer
     footer files
   body 
    body files

-logical modularity 
    object grouping
 sub modules
   header module 


Steps:

1.create folder
2.create modules
3.create components/directives/services 
4.DI inside sub module


Error: src/app/app.component.html:2:5 - error NG8001: 'app-header' is not a known element:
1. If 'app-header' is an Angular component, then verify that it is part of this module.
2. If 'app-header' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the '@NgModule.schemas' of this component to suppress this message.

2     <app-header></app-header>
      ~~~~~~~~~~~~


Module Scope:
Any Component,Pipe,Directive,submodule refers inside a module will be available inside that module only. Module Scope


Module Scope:

1.public scope
   if any objects belong to all modules that  is public
2.private scope
  if any objects belong to that module is private including appmodule.

if you want to make any object in public scope, you need to configer it

"exports: "
..............................................................................................
..............................................................................................
                       Angular CLI   Automate && accelerate your work flow
.............................................................................................

Problems in the dev flow:

Tasks:

1.create folder
2.create files - component-ts,html,css,spec
3.create module
4.declare class -cmp,service...
5.refer the classes inside module
6.you need to inject submodule into main module..

if you repeate the same thing for every object , which increases lot of time.

Automation:
 code generation automation

angular cli tool to generate code.

Generates and/or modifies files based on a schematic.

ng generate <schematic> [options]
ng g <schematic> [options]


//create folder, create module, inject this module into app module
>>ng g m footer --module=app
CREATE src/app/footer/footer.module.ts (192 bytes)
UPDATE src/app/app.module.ts (451 bytes)

create component, inside footer folder, inject into footer module, make it available public
i dont want css file,i want html file,i dontwant spec file

ng g c footer/footer  --flat=true --export=true --inline-style=true --skip-tests=true   --module=footer


 --flat=true :  create any thing inside exsiting folder
 --export=true : make it public
 --inline-style=true : i dont want css file
 --skip-tests=true  :dont create spec files
 --module=footer  : inject inside footer module

ng g m body --module=app   
ng g c body/body  --flat=true --export=true --inline-style=true --skip-tests=true   --module=body
..............................................................................................

...............................................................................................				Data binding
..............................................................................................

UI types

1.static ui
   only html
2.dynamic ui
  html + data and which change by user interactions

Data binding:
 Transfering state to ui(view)

Types of databinding

1.interpolation
2.property binding
3.attribute binding
4.event binding
5.two way data binding
6.class binding
7.style binding


MVC - Angular is MVC Framework
M- DATA
V-View -template
C - Controller - Component

...........................................................................................

Interpolation:
import { Component, OnInit } from '@angular/core';
import { Address } from '../types/address.type';

@Component({
  selector: 'app-interpolation',
  templateUrl: './interpolation.component.html',
  styles: [
  ]
})
export class InterpolationComponent implements OnInit {

  //instance variables ; models- data
  firstName: string = "Subramanian";
  age: number = 18;
  isValid: boolean = true;
  //objects
  address: Address = {
    city: 'Coimbatore',
    state: 'TN'
  };
  //Array
  skills: Array<string> = ["javascript", "angular", "typescript", "microservices"];


  constructor() { }

  ngOnInit(): void {
  }

}
<div>
    <h1>InterPolation</h1>
    <h2>Primitives</h2>
    <h3>String - {{firstName}}</h3>
    <h3>Number - {{age}}</h3>
    <h3>Boolean -{{isValid}}</h3>
    <h2>Object</h2>
    <h3>Object Properties {{address.city}} {{address.state}}</h3>
    <h2>Array</h2>
    <ul>
        <li *ngFor="let skill of skills">
            {{skill}}
        </li>
    </ul>

</div>
.............................................................................................
2.attribute binding
3.property binding

Angular instructions:
....................
Collection of symbols used inside html - template

{{}}
[]
*
#
()
[()]
..........................................................................................
			[] -  symbol used for property,attribute,style,class binding
...........................................................................................

What is   attribute and property? - []

<img src="imagelocation"/>
      |
 attribute
<a href="url">
   |
 attribute

Attribute values:
 - static attribute
eg:
   <img src="logo.png">


What is   attribute and property? - []

<img src="imagelocation"/>
      |
attribute

Why [] ?

  To bind value dynamically.
  
<img src="logo.png"/> -static image

<img [src]="variable"> - dynamic image

<div hidden> --- static value to hide div element

<div [hidden]="booleanvariable"> --- static value to hide div element

<button enabled>

<button [enabled="booleanvariable"> - dynamic value

if you use "[]"  on html elements which is called "attribute binding"
............................................................................................
				  Styling Components
.............................................................................................

Styles in angular :

1.global style
2.component specific style

global style:

style.css

bootstrap -  npm install bootstrap

angular.json
 "styles": [
              "src/styles.css",
              "./node_modules/bootstrap/dist/css/bootstrap.css"
            ],


<div class="container">
  <h1>Angular Data Binding</h1>
  <!-- <app-interpolation></app-interpolation> -->
  <app-attributes></app-attributes>
</div>

<div style="background-color: black; color: whitesmoke;">
    <h1>Attribute Binding</h1>
    <h2>Static Attribute - Static Image</h2>
    <img src="favicon.ico" />
    <h2>Dynamic Attribute - Dynamic Image</h2>
    <img [src]="imageLocation" />
    <h3>Dynamic Attribute - Enable or Disable Element</h3>
    <button [disabled]="isEnabled">Hello</button>
    <div [hidden]="isHidden">
        <h1>Hidden</h1>
    </div>
</div>
..............................................................................................
					Property Binding


What is property binding?
 Passing dynamic values  to the custom elements

Passing data from parent component to child component.
we can pass data upto n of childrens
Which is called "uni directional data flow model"
Components can be communicated via props binding.


<app-greet  [message]="variable|value"  ></app-greet>


@Component({
 selector:'app-greet',
 template: `<div> </div>
})
export class GreeterComponent{

}

Component Communication: - How components can pass data.

1.Parent -Child => via property binding
2.Child- Parent
3.across the components -sibilings -  via Services

.............................................................................................
			     Property binding
...........................................................................................

Passing data from parent component to child component.
we can pass data upto n of childrens
Which is called "uni directional data flow model"
Components can be communicated via props binding.

Two steps:

How to pass data from the parent to child?

1.From the parent component : passing data
  
  <app-greeter [message]="message">

 message:string="hello"

2. How to receive the data
   
   @Input() decorator
   message:string=""
................

  import { Component, OnInit } from '@angular/core';
  import { Address } from '../types/address.type';

  @Component({
    selector: 'app-parent',
    templateUrl: './parent.component.html',
    styles: [
    ]
  })
  export class ParentComponent implements OnInit {
    mymessage: string = "Hello! Property"
    address:Address = {
      city:'Coimbatore'
    }
    skills:Array<string> = ["java","javascript","Angular"]
    // address!: Address
    constructor() { }

    ngOnInit(): void {
    }

  }

parent.component.html
<h2>This is parent</h2>
<app-child [message]="mymessage" 
[address]="address" [skills]="skills">

</app-child>
  
............

import { Component, Input, OnInit } from '@angular/core';
import { Address } from '../types/address.type';

@Component({
  selector: 'app-child',
  templateUrl: './child.component.html',
  styles: [
  ]
})
export class ChildComponent implements OnInit {

  @Input()
  message: string = "";

  /**
   * ts config 
   * strict: true 
   * means that variable must have been initalized
   * but i dont want to make strict : false
   * there is solution : definite assigment operator "!"
   */
  @Input()
  address!: Address;

  @Input('skills')
  myskills!:Array<string>;

  constructor() { }

  ngOnInit(): void {
  }

}

child.component.html

<h2>Data from Parent</h2>
<h3>String {{message}}</h3>
<h3>Object {{address?.city ?? "Default city"}}</h3>
<h3>Array</h3>
<ul>
    <li *ngFor="let skill of myskills">
        <span>{{skill}}</span>
    </li>
</ul>

App component:
 <div>
    <h1>Property Binding</h1>
    <app-parent></app-parent>
  </div>
		..............................................................................................
					Event Binding
.............................................................................................


EventTarget Object: Event
  It connects dom object and listner method.
  where listener method can read values and other properties of dom object.

btn.addEventListener = function(evt){
  evt.target   

}
$event  - is global variable from the angular which has reference of EventTarget object


Two way binding:

-data is transfered from view to controller and controller to view 

How to implement two way data binding

1.events

///////////////////////////////////////////////////////////////////////////////////////////

Simple events:
<div>
    <button class="btn btn-success" (click)="onClick()" >Click</button>
    <!-- Pass data to listener -->
    <hr>
    <button class="btn btn-success" (click)="onReceive('hello how are you?')" >SendData</button>
</div>
import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-event',
  templateUrl: './event.component.html',
  styles: [
  ]
})
export class EventComponent implements OnInit {


  //listener function
  onClick() {
    alert('hello')
  }
  onReceive(message:string) {
    alert(message)
  }

  constructor() { }

  ngOnInit(): void {
  }

}
..........................................................................................
			How to read input from the keyboards
                           (Two way data binding)						
............................................................................................


import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { EventComponent } from './event.component';
import { InputComponent } from './input.component';
import { FormsModule } from '@angular/forms';



@NgModule({
  declarations: [
    EventComponent,
    InputComponent
  ],
  imports: [
    CommonModule,FormsModule
  ],
  exports: [
    EventComponent,
    InputComponent
  ]
})
export class EventbindingModule { }



import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-input',
  templateUrl: './input.component.html',
  styles: [
  ]
})
export class InputComponent implements OnInit {

  text:string = ""
  messageOne:string = ""
  messageTwo:string ="defaultvalue"
  messageThree:string = ""
  readInput(ctrl: any) {
    this.text = ctrl.target.value 
  }

  constructor() { }

  ngOnInit(): void {
  }

}

input.component.html

<div>
    <h2>Input Event</h2>
    <div>
        <h3>With Listener</h3>
        <h3>{{text}}</h3>
        <input (input)="readInput($event)">
    </div>

    <div>
        <h3>Without Listener</h3>
        <h3>{{messageOne}}</h3>
        <input (input)="messageOne=$event.target.value">
    </div>
    <div>
        <h3>Property Binding + Event Binding </h3>
        <h3>{{messageTwo}}</h3>
        <input  [value]="messageTwo" (input)="messageTwo=$event.target.value">
    </div>
    <div>
        <h3>Property Binding + Event Binding = Banana Box Notation [()] </h3>
        <h3>{{messageThree}}</h3>
        <input [(ngModel)]="messageThree">
    </div>
</div>
Types of events:

1.dom events - click,input,keypress.......
2.custom events - events for custom elements

Why custom events?

Component communcation:

1.parent to child - via props pattern
2.child to parent - via custom events
3.across components -  via services

2.child to parent - via custom events


Steps : write two components

1.parent
2.child

2.child to parent - via custom events



Steps : write two components

1.parent
2.child


Parent

import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-parent',
  templateUrl: './parent.component.html',
  styles: [
  ]
})
export class ParentComponent implements OnInit {

  constructor() { }

  ngOnInit(): void {
  }

}

2.Child Component

import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-child',
  templateUrl: './child.component.html',
  styles: [
  ]
})
export class ChildComponent implements OnInit {

  constructor() { }

  ngOnInit(): void {
  }

}

Step 2:

 EventEmitter:

Use in components with the @Output directive to emit custom events synchronously or asynchronously, and register handlers for those events by subscribing to an instance.

1.EventEmitter is used to broad cast values to Parent Components

class EventEmitter<T> extends Subject {
  constructor(isAsync?: boolean): EventEmitter<T>
  emit(value?: T): void
  subscribe(next?: (value: T) => void, error?: (error: any) => void, complete?: () => void): Subscription
}

2.EventEmitter object is Subclass Rxjs Subject.

create EventEmitter Object of type in child compoent.

eventemitter is used to send custom events.

   onSendRequest = new EventEmitter<string>();

3.We have to decorate eventemitter with @Output()

  @Output()
  onSendRequest = new EventEmitter<string>();

4.send data to Parent Component

    <div>
        <input [(ngModel)]="message">
    </div>
    <div>
        <button (click)="onSend()">Send To Parent</button>
    </div>

export class ChildComponent {

  message: string = "Good Value"
  //event emitter Declaration
  @Output()
  onSendRequest = new EventEmitter<string>();
  onSend() {
    alert('sending data to parent')
    //emit data  -  next method in subject
    this.onSendRequest.emit(this.message)
  }

}

5.Listens event and grab the data from the Child

<div>
    <h1 style="text-align: center;">Parent Component</h1>
    <h2>{{childMessage}}</h2>
</div>
<hr/>
<app-child (onSendRequest)="onReadData($event)" ></app-child>


export class ParentComponent {

  childMessage: string;

  onReadData(event: any) {
    this.childMessage = event
  }

}

/////////////

final code :

Child:
<div>
    <h1 style="text-align: center;">Child Component</h1>
    <div>
        <input [(ngModel)]="message">
    </div>
    <div>
        <button (click)="onSend()">Send To Parent</button>
    </div>
</div>


export class ChildComponent implements OnInit {

  message: string = "Good Value"
  //event emitter Declaration
  @Output()
  onSendRequest = new EventEmitter<string>();

  constructor() { }

  ngOnInit(): void {
  }
  onSend() {
    alert('sending data to parent')
    //emit data  -  next method in subject
    this.onSendRequest.emit(this.message)
  }

}


Parent:

<div>
    <h1 style="text-align: center;">Parent Component</h1>
    <h2>{{childMessage}}</h2>
</div>
<hr/>
<app-child (onSendRequest)="onReadData($event)" ></app-child>

export class ParentComponent {

  childMessage: string;
  onReadData(event: any) {
    this.childMessage = event
  }

}

..............................................................................................
				  Dynamic Css  - How to change Style dynamically
.............................................................................................
class binding and style binding
...............................

class binding:

<div [class.special]="isSpecial" [class]="classExpression">Some text.</div>

style binding:

<nav [style.background-color]="expression"></nav>
<nav [style.backgroundColor]="expression"></nav>



<div (click)="changeStyle()" [class.special]="isSpecial">Some text.</div>
<a [style.text-decoration]="activeLinkStyle">Home Page</a>

import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-dynamiccss',
  templateUrl: './dynamiccss.component.html',
  styles: [
  ]
})
export class DynamiccssComponent implements OnInit {
  isSpecial: boolean = true
  activeLinkStyle = 'overline';
  constructor() { }

  changeStyle() {
    this.isSpecial = !this.isSpecial
  }

  ngOnInit(): void {
  }

}

styles.css
.special {
   font-size: large;
   font-weight: 400;
   color:brown;
}
..............................................................................................
..............................................................................................
					..............................................................................................
				 Pipes
..............................................................................................

What is pipe?
 pipe object used for data formating.

eg:
 show uppercase
 show money values - $,#,
 show date format  - 1/10/2021 , feb 10 2021...
 custom formates

Angular provides lot of built in pipes, you can write your own pipes as well.
....
Syntax:
  some data | nameof the pipe.

Pipe with Input :
  some data | nameof the pipe:input.

Builtin pipes:

DatePipe: Formats a date value according to locale rules.

UpperCasePipe: Transforms text to all upper case.

LowerCasePipe: Transforms text to all lower case.

CurrencyPipe: Transforms a number to a currency string, formatted according to locale rules.

DecimalPipe: Transforms a number into a string with a decimal point, formatted according to locale rules.

PercentPipe: Transforms a number to a percentage string, formatted according to locale rules.

asyncPipe : to bind list of values async


<div>
  <h1 style="text-align: center;">Pipes</h1>
  <div>
    <h1>String</h1>
    <p>{{message | uppercase}}</p>
    <p>{{message | lowercase}}</p>
    <p>{{message | titlecase}}</p>
    <h1>Numbers</h1>
    <p>{{price | percent}}</p>
    <p>{{price | currency}}</p>
    <!-- pipe with input -->
    <p>{{price | currency:'INR'}}</p>
    <h1>Date</h1>
     <p>{{date | date}}</p>
     <p>{{date | date:'short'}}</p>
     <p>{{date | date:'dd/MM/yyyy'}}</p>

    <!-- Pipe chaining -->
    <p>{{date | date:'medium' | uppercase}}</p>

    <!-- Json -->
    <h1>JSON</h1>

    <p>{{employee | json}}</p>
    <h1>Custom Pipes</h1>
    <p>{{price | decimalfraction}}</p>
    <p>{{price | decimalfraction:3}}</p>
  </div>
</div>

<!-- 10.8766 --- >10.9 / 10.99 -->
import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
  name: 'decimalfraction'
})
export class DecimalfractionPipe implements PipeTransform {

  transform(value: number, numberofDigits: number = 1): string {
    return value.toFixed(numberofDigits)
  }

}

import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  title = 'pipes';
  message: string = "hello!"
  price: number = 1000.898766
  date = new Date();
  employee = {
    id: 1,
    name: 'subramanian',
    city: 'coimbatore'
  }
}
import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { DecimalfractionPipe } from './decimalfraction.pipe';



@NgModule({
  declarations: [
    DecimalfractionPipe
  ],
  imports: [
    CommonModule
  ],
  exports: [
    DecimalfractionPipe
  ]
})
export class UtilsModule { }
..............................................................................................
				 Directives
.............................................................................................

............................................................................................
					Directives
...........................................................................................

What is directive?
  Directive is custom element / attribute..

<app-root> ,<app-root [title]>


Types of Directives:
1.Template directive
2.Structural directive
3.Attribute directive




1.Template directive
   The directive with Template ; all components create template directive
  <app-root> ----------------template directive
  <app-profile>--------------template directive

All component's meta data is inherited from Directive meta.
Directive is parent , Component is child

Every component is directive.


2.Structural Directive
   It is type of directive, used to change HTML Layouts.
   They shape or reshape the DOM's "Structure" typically by adding,removing and manipulating
   the host elements to which they attached.
   
  -Host element means html elements eg div,span,li,table.
  -It is one of the "special attribute" directive
  -All structural directive starts with "*" notation.

Built in structural directives

1.*ngFor : for loop
2.*ngIf  : if condition
3.*ngSwitch : switch

..............................................................................................						    CommonModule

Where are structural directives?

ngFor itself is object part of commonmodule.

incase if you are using structural directives inside submodule, commonModule must have been injected.

if any component part of main module, we dont need to inject commonModule becuase BrowserModule which contains all structural directives.





List /Array rendering:
......................

Layouts:
1.List view Layout
   -ul li
2.Card View Layout
  div
3.Grid View Layout
  table tr td


1.for Loop: *ngFor

-where ever you want to repeate elements

element could be dom element or custom elements

eg:
 <anyelement *ngFor="condition">

 <div *ngFor="let variableName of arrayname">
       {{VariableName.property}}
 </div>
 This code will create more div elements

 <app-item-list *ngFor="">
Static view:
<ul>
        <li>1</li>
        <li>2</li>
        <li>3</li>

    </ul>

<div>
    <h1 style="text-align: center;">For loop</h1>

    <!--ul element-->
    <ul>
        <li *ngFor="let i of numbers">{{i}}</li>
    </ul>
    <!--Ui element for tod-->
    <ul class="list-group">
        <li class="list-group-item d-flex justify-content-between align-items-center" *ngFor="let todo of todos">
            <span class="badge badge-primary badge-pill"> {{todo.id}} </span> {{todo.title}}
        </li>

    </ul>
    <div class="card" *ngFor="let todo of todos">
        <h5 class="card-header">{{todo.id}}</h5>
        <div class="card-body">
            <h5 class="card-title">{{todo.userId}}</h5>
            <p class="card-text">{{todo.title}}</p>
            <a href="#" class="btn btn-primary">Update</a>
        </div>
    </div>
</div>

////////////////////////////////////////////////////////////////////////////////////////////

eg:
<div>
    <ul>
        <li *ngFor="let course of courses">
            {{course}}
        </li>
    </ul>
</div>
<h2>Users data</h2>
<div>
    <div *ngFor="let user of users">
        <h3>{{user.username}}</h3>
        <p>{{user.email}}</p>
        <address>
            <p>{{user.address.street}},{{user.address.city}}</p>
        </address>
    </div>
</div>

import { Component, OnInit } from '@angular/core';
import { USERS } from '../mock-data/users';

@Component({
  selector: 'app-forloop',
  templateUrl: './forloop.component.html',
  styles: [
  ]
})
export class ForloopComponent implements OnInit {

  courses: Array<string> = ["javascript", "angular", "Microservices"]

  users: Array<any> = USERS;




  constructor() { }

  ngOnInit(): void {
  }

}
.............................................................................................
				if..else,ngtemplate,#(template reference variable)
............................................................................................

import { Component, OnInit } from '@angular/core';
import { USERS } from '../mock-data/users';

@Component({
  selector: 'app-ifelse',
  templateUrl: './ifelse.component.html',
  styles: [
  ]
})
export class IfelseComponent implements OnInit {

  isEnabled: boolean = true
  users!: Array<any>;
  loading: boolean = true;
  status: string = "loading....."
  isHidden: boolean = false;

  constructor() {
    setTimeout(() => {
      this.users = USERS;
      this.loading = !this.loading;
    }, 5000);
  }

  toggle() {
    this.isHidden = !this.isHidden;
  }
  ngOnInit(): void {
  }

}
<div *ngIf="isEnabled; else mycondition">
    <h1>You have Facility!</h1>
</div>

<ng-template #mycondition>
    <h1>Sorry! Facility is not available</h1>
</ng-template>

<h2>Progress bar</h2>
<div *ngIf="loading; else notLoading  ">
    <h2>{{status}}</h2>
</div>
<ng-template #notLoading>
    <div *ngFor="let user of users">
        <h3>{{user.username}}</h3>
        <p>{{user.email}}</p>
        <address>
            <p>{{user.address.street}},{{user.address.city}}</p>
        </address>
    </div>
</ng-template>
<h2>Ng vs Hidden attribute</h2>
<button class="btn btn-success" (click)="toggle()">Toggle</button>
<!--Show and Hide-->
<!-- <div *ngIf="isHidden">
    <h1>Hello</h1>
</div> -->
<div [hidden]="isHidden">
    <h1>Hai</h1>
</div>
..............................................................................................
					Switch case
..............................................................................................

<h1 style="text-align: center;">Swich case </h1>
<input [(ngModel)]="input">
<button (click)="showFeedback()">Show Feedback</button>

<div [ngSwitch]="feedback">
    <p *ngSwitchCase="'good'">Good</p>
    <p *ngSwitchCase="'verygood'">Very Good</p>
    <p *ngSwitchCase="'bad'">Bad</p>
    <p *ngSwitchDefault>Your input is not matching</p>
</div>

<div [ngSwitch]="feedback">
    <ng-template [ngSwitchCase]="'good'">
        <h3>Good</h3>
    </ng-template>
    <ng-template [ngSwitchCase]="'verygood'">
        <h3>Very Good</h3>
    </ng-template>
    <ng-template [ngSwitchCase]="'bad'">
        <h3>bad</h3>
    </ng-template>
    <ng-template ngSwitchDefault>
        <h3>Your input is not matching</h3>
    </ng-template>
</div>
import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-switchcase',
  templateUrl: './switchcase.component.html',
  styles: [
  ]
})
export class SwitchcaseComponent implements OnInit {

  input: string = ""
  feedback: string = "good"
  constructor() { }
  showFeedback() {
    this.feedback = this.input
  }

  ngOnInit(): void {
  }

}
..............................................................................................
				   Attribute Directives
.............................................................................................

How to add new extra attributes on html elements

<div myattribute=somevalue>

 Adding extra behaviour to existing dom elements.

eg:
 <div subu="">

 <div appHighlight>

How to create our own attribute directive.

import { Directive, ElementRef, HostListener } from '@angular/core';

@Directive({
  selector: '[appHighlight]'
})
export class HighlightDirective {

  constructor(private element:ElementRef) { 
    //  console.dir(this.element.nativeElement)
    this.element.nativeElement.style.backgroundColor = 'yellow'
  }
  @HostListener('mouseenter')
  onMouseEnter() {
    this.highLight('blue')
  }
  @HostListener('mouseleave')
  onMouseLeave() {
    this.highLight(null)
  }
  private highLight(color: any) {
    this.element.nativeElement.style.backgroundColor = color
  }
}
<div>
    <h1 appHighlight>IBM</h1>

    <p appHighlight>IBM</p>

</div>
..............................................................................................
					Forms
.............................................................................................

Template Reference Variable #

DOM Object :  Every HTML Element is Object called DOM object

<h1> -object
<div> - object

How to access DOM object inside code(component/directive).

1.inside component.
  $event
2.inside directive(Attribute)
  ElementRef

How to access DOM object inside template itself(across template)

<div>
 <h1 #myvar >Hello</h1>

 <div> 
    {{myvar.innerHTML}}
 </div>

</div>
Forms are used to get input from the User.

Types of Forms

1.Template driven Forms
2.Reactive forms


Tempate Driven Forms:
...................

Steps:

1.FormsModule

import { NgModule } from '@angular/core';
import { FormsModule } from '@angular/forms';
import { BrowserModule } from '@angular/platform-browser';
import { AppComponent } from './app.component';

@NgModule({
  declarations: [
    AppComponent
  ],
  imports: [
    BrowserModule,
    FormsModule
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }

2.declare FormModel Object going to hold form field data

export class PostFormModel{
    constructor(public id: number, public title: string, public author: string){
    }
}

3.Create Model Object inside component.

export class AppComponent {
  post: any;
  constructor() {
    this.post = new PostFormModel(Math.random(), 'Learn Angular', 'Misko')
  }
}

Step 4 : 
Create inital form Template
 -Forms should have bootstrap style

<div class="container">
  <h1>Post Form</h1>
  <form>
    <div class="form-group">
      <label for="title">Title</label>
      <input type="text" class="form-control" id="title" required>
    </div>

    <div class="form-group">
      <label for="name">Name</label>
      <input type="text" class="form-control" id="name" required>
    </div>

    <button type="submit" class="btn btn-success">Submit</button>

  </form>
</div>


Step 5:

Data binding
   Binding textbox(form controls) with Model Object
   We have many ways
  1.through instance variable,$event
  2.through [(ngModel)]="post.title"
   ngModel = > it is an object from "FormsModule"
   ngModel it is dto object=>data transfering between view and component.

//
Form Control value property is bound with name property of input control.

<input [(ngModel)]="post.title" name="title" type="text" class="form-control" id="title" required>

    <form>
       <!--TODO: Remove this once testing over-->
       <pre>{{post | json}}</pre>
      <div class="form-group">
         <label for="title">Title</label>
         <input [(ngModel)]="post.title" name="title" type="text" class="form-control" id="title" required>
       </div>
       <div class="form-group">
         <label for="name">Name</label>
         <input [(ngModel)]="post.author" name="author" type="text" class="form-control" id="name" required>
       </div>
   
       <button type="submit" class="btn btn-success">Submit</button>
    </form>

*****************************************************************************************
					Vaildation
///////////////////////////////////////////////////////////////////////////////////////////

Objects In the FormsModule:

NgForm : 

 It is object representation of "form" element.
 Can be used to control form validations.
 in order to access the NgForm object inside template. You have to use template reference

<form #postForm> =>postForm points HTMLForm Object

ngForm is Object which inherits HTMLForm

class ngForm extends HTMLForm{
  +extra behavior=>Ready made validation code
  +form submission behviours
}

What is meaning of this code <form #postForm>?

 HTMLFORMMobject ----postPorm

dummy code for the above template
 let postForm =  new HTMLForm();

what we need
 let postForm = new NgForm()

<form #postForm="ngForm"> 


The variable postForm is now a reference to the NgForm 
directive that governs the form as a whole.

The NgForm directive:

What NgForm directive? You didn't add an NgForm directive before.

Angular did. Angular automatically creates and attaches
 an NgForm directive to the <form> tag.

"The NgForm directive supplements the form element with additional features. 

It holds the controls you created for the elements  with an "ngModel directive" and name attribute, and monitors their properties, including their validity.
 
It also has its own valid property which is true only if every contained control is valid."

Note: NgForm is built Object ,has more logic for simlifying our form handling process.

********************************************************************************************
********************************************************************************************
NgModel :

 1.Transfering data between UI and Controller .

NgModel not only for data transfer, which does so many other things beyond twoway data binding.

Track control(form element) state and validity with ngModel:
............................................................

Form element states:

Angular provides built-in css classes to track form control state"

State 	                         Class if true 	  Class if false

The control has been visited.  	  ng-touched 	    ng-untouched
The control's value has changed.  ng-dirty 	    ng-pristine
The control's value is valid. 	  ng-valid 	    ng-invalid

State Tracking Steps:

1.Look but don't touch.
2.Click inside the name box, then click outside it.
3.Add slashes to the end of the name.
4.Erase the name.

ng-untouched - if you dont touch
ng-touched - if you touch
ng-dirty - if you changed
ng-invalid - if you remove all-empty field

Step 6:

Add custom CSS for visual feedback:

Valid + Required - green Color
Valid + optional - white color
Invalid (required | optional) - red Color

Angular Css:

.ng-valid[required], .ng-valid.required  {
  border-left: 5px solid #42A948; /* green */
}

.ng-invalid:not(form)  {
  border-left: 5px solid #a94442; /* red */
}

****************************************************************************************

Adding validation block to our code:
...................................

NgModel is Child Object of FormControl Object

class  Input{
 
}
class NgModel extends Input{
  //extra features : state tracking,enabling validation.
}

<input #Xx> -Here xxPoints only Input

<input #Xx="ngModel"> -Here xx points ngModel

      <input  [(ngModel)]="post.title" #errorMsg1="ngModel" name="title" type="text" class="form-control" id="title" required>

Step 7: Add Error Block
<div class="container">
  <h1>Post Form</h1>
  <form #postForm="ngForm">
    <!--TODO: Remove this once testing over-->
    <pre>{{post | json}}</pre>
    <div class="form-group">
      <label for="title">Title</label>
      <input [(ngModel)]="post.title" #errorMsg1="ngModel" name="title" type="text" class="form-control" id="title"
        required>
      <div [hidden]="errorMsg1.valid || errorMsg1.pristine" class="alert alert-danger">
        title is required
      </div>
    </div>

    <div class="form-group">
      <label for="name">Name</label>
      <input [(ngModel)]="post.author" #errorMsg2="ngModel" name="author" type="text" class="form-control" id="name"
        required>
      <div [hidden]="errorMsg2.valid || errorMsg2.pristine" class="alert alert-danger">
        Author is required
      </div>
    </div>
    <button type="submit" class="btn btn-success">Submit</button>

  </form>
</div>

Step 7: Disabling submit button until the whole form is valid.
*******************************************************************************************

Disabling submit button in case any validation fails:

  <button type="submit" class="btn btn-success" [disabled]="!postForm.form.valid">Submit</button>

*******************************************************************************************


Step 8:Adding combo box: Select Control


export class PostFormModel {
    constructor(public id: number, public title: string, public author: string, public category: string) {
    }
}
export class AppComponent {
  post: any;
  //you may get  this from services
  categories: Array<string> = ["User interface", "MicroServices", "Devops"];
  constructor() {
    this.post = new PostFormModel(Math.random(), 'Learn Angular', 'Misko', this.categories[0])
  }
}

    <div class="form-group">
      <label for="category">Category</label>
      <select class="form-control" id="category" name="category" 
       [(ngModel)]="post.category">
        <option *ngFor="let cat of categories"  [value]="cat">
          {{cat}}
        </option>
      </select>
    </div>
////////////////////////////////////////////////////////////////////////////////////////////

Step 9: How to submit Form? and show another page

Add listener in the form tag.
 <form #postForm="ngForm" (ngSubmit)="onSubmit()">


<div class="container">
  <h1>Post Form</h1>
  <div [hidden]="submitted">
    <form #postForm="ngForm" (ngSubmit)="onSubmit()">
      <!--TODO: Remove this once testing over-->
      <pre>{{post | json}}</pre>
      <div class="form-group">
        <label for="title">Title</label>
        <input [(ngModel)]="post.title" #errorMsg1="ngModel" name="title" type="text" class="form-control" id="title"
          required>
        <div [hidden]="errorMsg1.valid || errorMsg1.pristine" class="alert alert-danger">
          title is required
        </div>
      </div>

      <div class="form-group">
        <label for="name">Name</label>
        <input [(ngModel)]="post.author" #errorMsg2="ngModel" name="author" type="text" class="form-control" id="name"
          required>
        <div [hidden]="errorMsg2.valid || errorMsg2.pristine" class="alert alert-danger">
          Author is required
        </div>
      </div>

      <div class="form-group">
        <label for="category">Category</label>
        <select class="form-control" id="category" name="category" [(ngModel)]="post.category">
          <option *ngFor="let cat of categories" [value]="cat">
            {{cat}}
          </option>
        </select>
      </div>


      <button type="submit" class="btn btn-success" [disabled]="!postForm.form.valid">Submit</button>
    </form>
  </div>

  <!--Details Page-->
  <div class="container" [hidden]="!submitted">
    <h2>You submitted the following:</h2>
    <div class="row">
      <div class="col-xs-3">Id : </div>
      <div class="col-xs-9  pull-left">{{ post.id }}</div>
    </div>
    <div class="row">
      <div class="col-xs-3">Title : </div>
      <div class="col-xs-9  pull-left">{{ post.title }}</div>
    </div>
    <div class="row">
      <div class="col-xs-3">Author : </div>
      <div class="col-xs-9 pull-left">{{ post.author }}</div>
    </div>
    <div class="row">
      <div class="col-xs-3">Category : </div>
      <div class="col-xs-9 pull-left">{{ post.category }}</div>
    </div>
    <br>
    <button class="btn btn-primary" (click)="submitted=false">GoBack</button>
  </div>

</div>

import { Component } from '@angular/core';
import { PostFormModel } from './post.form.model';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  post: any;
  submitted: boolean = false;
  //you may get  this from services
  categories: Array<string> = ["User interface", "MicroServices", "Devops"];
  constructor() {
    this.post = new PostFormModel(Math.random(), 'Learn Angular', 'Misko', this.categories[0])
  }
  onSubmit(){
     alert(JSON.stringify(this.post))
     this.submitted = true;
  }
}


export class PostFormModel {
    constructor(public id: number, public title: string, public author: string, public category: string) {
    }
}
.............................................................................................
					 Services
.............................................................................................
					
What is service ?

 Service itself is object holding data and biz logic.
 Service need to be accessed inside controller(component).


Java -Spring -Dependency Injection

class HelloService{

}

class HelloComponent {
 private HelloService helloService;

 //constructor injection
  HelloComponent(HelloService helloService){
      this.helloService =helloSerice
   }
 //setter injection
  public void setHelloService(HelloService helloService){
     this.helloService=HelloService
  }
}

HelloService helloService =new HelloService();
HelloComponent cmp = new HelloComponent(helloService)
cmp.setHelloService(helloService);


In Angular =>Typescript


@Injectable()
export class HelloService{
	
   //methods
}

@Component()
export class HelloComponent {
 //private HelloService helloService;
 //constructor injection
  constructor(private helloService:HelloService){
     // this.helloService =helloSerice
  }
  
}

In module:

providers: [HelloService]

This angular takes cares
let helloService =new HelloService();
let cmp = new HelloComponent(helloService)

........................................................................................................

Angular Component/Directive Life Cycle method sequence:

@Component()
export class MyComponent {}

new MyComponent()

  1.constructor is called

  2.ngOnChanges() -  only if any input properties are found

  3.ngOnInit()  - used to initalize the state after component is mounted.
		   used for data intialization,timers,websockets,ajax inital code.

  ...

  4.ngOnDestroy() - used to destroy resources allocated
                    removing timers,unsubscribering observable
.......................................................................................................

import { Component, OnInit, SimpleChanges } from '@angular/core';

@Component({
  selector: 'app-cmplifecycle',
  templateUrl: './cmplifecycle.component.html',
  styles: [
  ]
})
export class CmplifecycleComponent implements OnInit {
  counter: number = 1;

  constructor() {
    console.log('CmplifecycleComponent- constructor is called')
  }
  ngOnChanges(changes: SimpleChanges) {
    for (const propName in changes) {
      const chng = changes[propName];
      const cur = JSON.stringify(chng.currentValue);
      const prev = JSON.stringify(chng.previousValue);

    }
    console.log('CmplifecycleComponent- ngOnchanges')
  }
  ngOnInit(): void {
    console.log('CmplifecycleComponent -ngOnInit is called')
  }
  increment() {
    this.counter++;
  }
  //resource deallocation code
  ngOnDestroy() {
    console.log('CmplifecycleComponent -ngOnDestroy is called')
  }

}
<div>
    <h1>Parent Component</h1>
    <app-child [counter]="counter" ></app-child>
    <button (click)="increment()">increment</button>
</div>

.........................


import { Component, Input, OnInit, SimpleChanges } from '@angular/core';

@Component({
  selector: 'app-child',
  templateUrl: './child.component.html',
  styles: [
  ]
})
export class ChildComponent implements OnInit {
  @Input()
  counter: number = 0;

  constructor() {
    console.log('Child Component constructor is called')
  }

  //called only if component receives props from the parent component
  ngOnChanges(changes: SimpleChanges) {
    for (const propName in changes) {
      const chng = changes[propName];
      const cur = JSON.stringify(chng.currentValue);
      const prev = JSON.stringify(chng.previousValue);
      console.log(chng)
    }
    console.log('ChildComponent- ngOnchanges')
  }

  //only one time
  ngOnInit(): void {
    console.log('ChildComponent -ngOnInit is called')
  }

}
<p>child works!</p>
..............................................................................................

Service : Object creation and use

import { Injectable } from "@angular/core";


@Injectable({
    providedIn: 'root' // we tell the angular that use "root injector to create object"
})
export class GreetingService {
    constructor() {

    }
    //methods
    public sayHello(): string {
        return "Hello Service!!";
    }
    public sayHai(): string {
        return "Hai"
    }
    public sayGreet(): string {
        return "Greet";
    }

}

import { Component, OnInit } from '@angular/core';
import { GreetingService } from './greeing.service';

@Component({
  selector: 'app-greeting',
  templateUrl: './greeting.component.html',
  styles: [
  ]
})
export class GreetingComponent implements OnInit {

  // message:string = "Hello";
  message: string = "";
  hai:string = ""
  greet:string = ""
  //constructor injection
  constructor(private greetingService: GreetingService) {
    // // console.log(this.helloService.sayHello());
    // this.message = this.greetingService.sayHello();
    // this.hai = this.greetingService.sayHai();
    // this.greet = this.greetingService.sayGreet();
  }

  ngOnInit(): void {
    this.message = this.greetingService.sayHello();
    this.hai = this.greetingService.sayHai();
    this.greet = this.greetingService.sayGreet();
  }

}
.......................................................................................................

Services can take other service as dependency
.............................................

@Injectable({providedIn:'root'})
export class Logger {

}

@Injectable({
    providedIn: 'root' // we tell the angular that use "root injector to create object"
})
export class GreetingService {
    constructor(private logger:Logger) {

    }
    //methods
    public sayHello(): string {
      
        return "Hello Service!!";
    }
    public sayHai(): string {
        return "Hai"
    }
    public sayGreet(): string {
        return "Greet";
    }

}

.......................................................................................................

import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root'
})
export class LoggerService {

  constructor() { }

  private messages: string[] = [];

  add(message: string) {
    this.messages.push(message);
  }
  fetch(): string[] {
    return this.messages;
  }

  clear() {
    this.messages = [];
  }
}

greetingservice
import { Injectable } from "@angular/core";
import { LoggerService } from "../util/logger.service";


@Injectable({
    providedIn: 'root' // we tell the angular that use "root injector to create object"
})
export class GreetingService {
    //GreetingService has LoggerService dependency
    constructor(private logger: LoggerService) { }
    //methods
    public sayHello(): string {
        this.logger.add('SayHello method  is called')
        return "Hello Service!!";
    }
    public sayHai(): string {
        this.logger.add('sayHai method  is called')
        return "Hai"
    }
    public sayGreet(): string {
        this.logger.add('sayGreet method  is called')
        return "Greet";
    }

}
...........

Component
import { Component, OnInit } from '@angular/core';
import { LoggerService } from '../util/logger.service';
import { GreetingService } from './greeing.service';

@Component({
  selector: 'app-greeting',
  templateUrl: './greeting.component.html',
  styles: [
  ]
})
export class GreetingComponent implements OnInit {

  // message:string = "Hello";
  message: string = "";
  hai: string = ""
  greet: string = ""
  logMessages: string[] = [];
  //constructor injection
  constructor(private greetingService: GreetingService, private logger: LoggerService) {
    // // console.log(this.helloService.sayHello());
    // this.message = this.greetingService.sayHello();
    // this.hai = this.greetingService.sayHai();
    // this.greet = this.greetingService.sayGreet();
  }

  ngOnInit(): void {
    this.message = this.greetingService.sayHello();
    this.logMessages=this.logger.fetch()
    this.hai = this.greetingService.sayHai();
    this.logMessages=this.logger.fetch()
    this.greet = this.greetingService.sayGreet();
    this.logMessages=this.logger.fetch()

  }

}
........................................................................................................
..............................................................................................
				 Types of services

1.Sync services
  blocking services which blocks the current thread, so that ui will be freezed until the data
or result is available.
 
2.Async services
  Non blocking
  the task which wont block the current thread.
  The computation will be done in other threads, once the task is over the result will be handed over to main thread.


How to implement async programming in js(angular)?

1.callback pattern - core pattern
2.Promise pattern - wrapper for callbacks
3.Reactive programming-rxjs


callback pattern :
 passing function as parameter to another function, which gets called once async operation is completed

What could be async operation:

1.ajax call
2.timers
3.websockets



import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root'
})
export class CallbackpatternService {
  constructor() { }

  //biz method sync method
  public getValue(): number {
    return 10;
  }
  //biz method : async method : timer
  public delayValue(callback: any): void {
    //timer : Return "Hello" message to the caller after 5ms .
    setTimeout(callback, 5000, 100);
  }


}
import { Component, OnInit } from '@angular/core';
import { CallbackpatternService } from './callbackpattern.service';

@Component({
  selector: 'app-callbackpattern',
  templateUrl: './callbackpattern.component.html',
  styles: [
  ]
})
export class CallbackpatternComponent implements OnInit {

  syncValue: number = 0;
  asyncValueCb: number = 0;
  loading: boolean = true;
  status: string = "loding..."

  constructor(private cbService: CallbackpatternService) { }

  ngOnInit(): void {
    //sync call 
    this.syncValue = this.cbService.getValue();
    //async call
    this.cbService.delayValue((value: number) => {
      this.asyncValueCb = value;
      this.loading = false;
    });

  }

}
<div>
    <h1>Callback Pattern</h1>
    <h2>Sync Value : {{syncValue}}</h2>
    <div *ngIf="loading; else notLoading  ">
        <h2>{{status}}</h2>
    </div>
    <ng-template #notLoading>
         <h3>{{asyncValueCb}}</h3>
    </ng-template>
</div>
........................................................................................................

Promises:

=>It is a design pattern to abstract callback pattern.
=>We dont need to pass function as parameter



import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root'
})
export class PromisepatternService {

  constructor() { }

  //async code with promises
  getValue(): Promise<number> {
    return new Promise((resolve, reject) => {
      setTimeout(resolve, 5000, 1000)
    });
  }

}
...................................................................................................

import { Component, OnInit } from '@angular/core';
import { PromisepatternService } from './promisepattern.service';

@Component({
  selector: 'app-promisespattern',
  templateUrl: './promisespattern.component.html',
  styles: [
  ]
})
export class PromisespatternComponent implements OnInit {

  value: number = 0;
  constructor(private promiseService: PromisepatternService) { }

  ngOnInit(): void {
    this.promiseService.getValue()
      .then(value => {
        this.value = value;
      }).catch(err => console.log(err))
  }

}
<div>
    <h1>Promise Value {{value}}</h1>
</div>
........................................................................................................
					Reactive programming- Rxjs
	

What is Reactive programming?
  An API for asynchronous programming with observable streams.
Reactive Programming is new Programming style  which coimbines
->Observer Design pattern
->Iterator Design pattern
->Functional Programming principles

Why Reactive Programming?

 Data Transfer and Data Processing among system


Programming Type with respect data transfer

1.PULL Based Programming
   The One Object ask the Other Object

The Requester is called "Client/Subscriber"

The Giver is called "Provider/Publisher"

Client always asks data, Provider always gives data.

Client when ever requet, the Provider will give data.



2.PUSH based Programming

Where publisher sends the data without client request.

=>Event Driven programming model where publisher sends events , where subscriber listens for the event

Publihser will send three types of events

1.data event
2.error event
3.complete event
........................................................................................................

Characteristics of reactive programming:

1.data is streammed from publisher to subscriber , so that performance is increased
2.stream can be observed - data processing is possible
3.reactive is more declarative - more readable, less code. 
4.abstract low level concurrency implemenations- multi threading.....
.......................................................................................................

Reactive Programming is platform ,language independant.


rxjava-java
rxjs -javascript
etc...
Java script + Reactive Programming = rxjs

What is rxjs?

rxjs is javascript lib for writing reactive programming in js echo system.

rxjs and angular:

angular uses rxjs for data streaming and processing in async way.

angular uses rxjs in many places
 - http programming
 - routers
 - child to parent communication.
........................................................................................................
					Rxjs Implementation
........................................................................................................

Core concepts In rxjs

1.Observables
2.Observer - Subscriber
3.Operators - methods
4.Subscription - bridge between Observable and Observer
5.Subjects
6.Scheduler


Objects:
1.Publisher
2.Subscriber

API (Operators /methods/function) for Processing Streaming

Publisher Objects:

1.Observable
2.Subject

........................................................................................................
					Angular and Rxjs

Service : Publisher

Component: Listener/Subscriber



import { Injectable } from '@angular/core';
import { Observable } from 'rxjs';

@Injectable({
  providedIn: 'root'
})
export class ObservableService {

  constructor() { }

  //method which returns an observable
  public createSimpleStream(): Observable<number> {
    return new Observable(observer => {
      //push value / error / complete
      observer.next(10) // push value into stream
      observer.next(20)
      observer.next(30)
      observer.next(40)
      observer.next(50)
      observer.complete();
    });
  }
  //in 


}

import { Component, OnInit } from '@angular/core';
import { Subscription } from 'rxjs';
import { ObservableService } from './observable.service';

@Component({
  selector: 'app-observable',
  templateUrl: './observable.component.html',
  styles: [
  ]
})
export class ObservableComponent implements OnInit {

  stream$: Array<number> = [];

  //! => definit assignment assertion property
  subscription!: Subscription;

  constructor(private obsService: ObservableService) { }
  //listener who listens for data

  ngOnInit(): void {
    // this.obsService.createSimpleStream().subscribe(data => {
    //   console.log(data);
    //   this.stream$.push(data);
    // }, error => {
    //   console.log('error')
    // }, () => {
    //   console.log('completed')
    // });
    //subscribe({next: {},complete:{},error:{}})
    this.subscription = this.obsService.createSimpleStream().subscribe({
      next: (data: number) => {
        console.log(data)
        this.stream$.push(data);
      },
      complete: () => { },
      error: () => { }
    });

  }
  //called once the when the component is destroyed
  ngOnDestory() {
    //remove Observable from the memory
    this.subscription.unsubscribe();
  }

}
........................................................................................................

Operators:
.........
Operators are functions. There are two kinds of operators:



1.Pipeable Operators are the kind that can be piped to Observables using the syntax observableInstance.pipe(operator()). 
  => For data Processing.

2.Creation Operators 
	are the other kind of operator, which can be called as standalone functions to create a new Observable

  Creation operators are utiltity operators which is used to create stream based on data sources.

Data Sources:
 - sequenece primitives
 - array
 - map
 - Promises
 - DOM events

........................................................................................................

Operators : of,from

import { Injectable } from '@angular/core';
import { from, Observable, of } from 'rxjs';

@Injectable({
  providedIn: 'root'
})
export class ObservableService {

  constructor() { }

  //method which returns an observable
  public createSimpleStream(): Observable<number> {
    return new Observable(observer => {
      //push value / error / complete
      observer.next(10) // push value into stream
      observer.next(20)
      observer.next(30)
      observer.next(40)
      observer.next(50)
      observer.complete();
    });
  }
  //creational operators : of
  public createOf(): Observable<number> {
    return of(10, 20, 30, 40, 50) // ob
  }
  //creational operator : from

  public createFrom(): Observable<number> {
    return from([10, 20, 30, 40, 50])
  }


}

import { Component, OnInit } from '@angular/core';
import { Subscription } from 'rxjs';
import { ObservableService } from './observable.service';

@Component({
  selector: 'app-fromobservable',
  templateUrl: './fromobservable.component.html',
  styles: [
  ]
})
export class FromobservableComponent implements OnInit {
  stream$: Array<number> = [];
  subscription!: Subscription;

  constructor(private obsService: ObservableService) { }

  ngOnInit(): void {
    this.subscription = this.obsService.createFrom().subscribe({
      next: (data: number) => {
        console.log(data)
        this.stream$.push(data);
      },
      complete: () => { },
      error: () => { }
    });
  }
  ngOnDestory() {
    //remove Observable from the memory
    this.subscription.unsubscribe();
  }
}
<div>
    <h1>Observable - From</h1>
    <ul>
        <li *ngFor="let num of stream$">{{num}}</li>
    </ul>
</div>
.........

import { Component, OnInit } from '@angular/core';
import { Subscription } from 'rxjs';
import { ObservableService } from './observable.service';

@Component({
  selector: 'app-ofobservable',
  templateUrl: './ofobservable.component.html',
  styles: [
  ]
})
export class OfobservableComponent implements OnInit {
  stream$: Array<number> = [];
  subscription!: Subscription;

  constructor(private obsService: ObservableService) { }

  ngOnInit(): void {
    this.subscription = this.obsService.createOf().subscribe({
      next: (data: number) => {
        console.log(data)
        this.stream$.push(data);
      },
      complete: () => { },
      error: () => { }
    });
  }
  //called once the when the component is destroyed
  ngOnDestory() {
    //remove Observable from the memory
    this.subscription.unsubscribe();
  }

}
<div>
    <h1>Observable - Of</h1>
    <ul>
        <li *ngFor="let num of stream$">{{num}}</li>
    </ul>
</div>
.......................................................................................................
				Without Subscribe method how to  access data
.......................................................................................................

We have a special pipe called async

import { Injectable } from '@angular/core';
import { from, Observable, of } from 'rxjs';

@Injectable({
  providedIn: 'root'
})
export class ObservableService {

  constructor() { }
  //Return an array 
  public createArray(): Observable<number[]> {
    return of([10, 20, 30, 40, 50])
  }


}
import { Component, OnInit } from '@angular/core';
import { Observable, Subscription } from 'rxjs';
import { ObservableService } from './observable.service';

@Component({
  selector: 'app-fromobservable',
  templateUrl: './fromobservable.component.html',
  styles: [
  ]
})
export class FromobservableComponent implements OnInit {
  stream$: Array<number> = [];
  subscription!: Subscription;
  //For Async Pipe
  streamAsync!: Observable<number[]>;

  constructor(private obsService: ObservableService) { }

  ngOnInit(): void {
    //with subscribe method
    this.subscription = this.obsService.createFrom().subscribe({
      next: (data: number) => {
        console.log(data)
        this.stream$.push(data);
      },
      complete: () => { },
      error: () => { }
    });

    //
    this.streamAsync = this.obsService.createArray()

  }
  ngOnDestory() {
    //remove Observable from the memory
    this.subscription.unsubscribe();
  }
}
<div>
    <h1>Observable - From</h1>
    <ul>
        <li *ngFor="let num of stream$">{{num}}</li>
    </ul>

    <h1>Observable - From With async</h1>
    <ul>
        <li *ngFor="let val of streamAsync | async">{{val}}</li>
    </ul>
</div>

.............................................................................................
				  Data Processing 


Functional Programming:

->Pure function
    The function which does not modify the original data state.
   
->immutablity
    The function which returns always new data.


//this impure function and mutates the original object
function update(profile , city){
   
   //logic update:
   profile.city = city;
   return profile

}

const profile= {
 id:2
 name:'foo',
 city:'bar'
}

const result = update(profile,'coimbatore')



//pure function , having immutable logic

function update(profile , city){
   
   //logic update:
   return {
       id:profile.id,
       name:profile.name
       city: city
   }

}

const profile= {
 id:2
 name:'foo',
 city:'bar'
}

const result = update(profile,'coimbatore')


Every rxjs operation is pure function and always returns new object(immutable object).

  Observable = of(somedata)

  of(somedata).pipe(map(somelogic)=>new Observable, other operator=>new Observable())


Stream Types:

1.up Stream
2.down stream


<div>
    <h1>Data processing-Using Map</h1>
    <ul>
        <li *ngFor="let num of stream$">{{num}}</li>
    </ul>

    <h1>Data processing-Using Filter</h1>
    <ul>
        <li *ngFor="let num of streamFilter$">{{num}}</li>
    </ul>
</div>

import { Component, OnInit } from '@angular/core';
import { Observable, Subscription } from 'rxjs';
import { DataProcessingService } from './dataprocessing.service';

@Component({
  selector: 'app-dataprocessing',
  templateUrl: './dataprocessing.component.html',
  styles: [
  ]
})
export class DataprocessingComponent implements OnInit {
  stream$: Array<number> = [];

  streamFilter$:Array <number> =[]
  subscription!: Subscription;
  //For Async Pipe
  streamAsync!: Observable<number[]>;

  constructor(private obsService: DataProcessingService) { }

  ngOnInit(): void {
    this.subscription = this.obsService.transformUsingMap().subscribe({
      next: (data: number) => {
        console.log(data)
        this.stream$.push(data);
      },
      complete: () => { },
      error: () => { }
    });

    //filtering data
    this.obsService.filterByValue().subscribe({
      next: (data: number) => {
        console.log(data)
        this.streamFilter$.push(data);
      },
      complete: () => { },
      error: () => { }
    });

  }

  ngOnDestory() {
    //remove Observable from the memory
    this.subscription.unsubscribe();
  }

}
import { Injectable } from "@angular/core";
import { Observable, of, range, filter } from "rxjs";
import { map,takeLast } from 'rxjs/operators'

@Injectable({
    providedIn: 'root'
})
export class DataProcessingService {
    constructor() { }

    public transformUsingMap(): Observable<number> {
        //data processing operators
        return range(1, 20).pipe(map(x => x * 2), map(x => x * 4));
    }

    public filterByValue(): Observable<number> {
        return range(1, 25).pipe(filter(x => x % 2 === 1),takeLast(5))
    }

}
..............................................................................................

..............................................................................................						Multi cast
..............................................................................................

There are two ways to broadcast values 

1.cold stream
2.hot stream


1.cold stream

1.Observable that doesn’t emit items until a subscriber subscribes.

2.If we have more than one subscriber, then observable will 
emit sequence of items to all subscribers one by one.

3.Each subscriber get "fresh copy of the data from the begining".

4.Most of Observerables are Cold.
..............................................................................................

import { Injectable } from '@angular/core';
import { interval, Observable } from 'rxjs';
import { tap } from 'rxjs/operators';

@Injectable({
  providedIn: 'root'
})
export class ColdstreamService {

  constructor() { }

  //cold stream api
  public emitValue(): Observable<number> {
    return interval(1000).pipe(tap(() => console.log('emitting')));
  }
}

Subscriber1
import { Component, OnInit } from '@angular/core';
import { Subscription } from 'rxjs';
import { ColdstreamService } from './coldstream.service';

@Component({
  selector: 'app-cstreamsub1',
  templateUrl: './cstreamsub1.component.html',
  styles: [
  ]
})
export class Cstreamsub1Component implements OnInit {
  values: number[] = [];
  subscription!: Subscription;

  constructor(public coldService: ColdstreamService) { }
  ngOnInit(): void {
    this.subscription = this.coldService.emitValue().subscribe(data => {
      this.values.push(data);
    })
  }
  ngOnDestory() {
    console.log('component has been destroyed')
    this.subscription.unsubscribe()
  }

}
<h1>Subscriber-1</h1>
<ul>
    <li *ngFor="let i of values">
        {{i}}
    </li>
</ul>

...

import { Component, OnInit } from '@angular/core';
import { Subscription } from 'rxjs';
import { ColdstreamService } from './coldstream.service';

@Component({
  selector: 'app-cstreamsub2',
  templateUrl: './cstreamsub2.component.html',
  styles: [
  ]
})
export class Cstreamsub2Component implements OnInit {
  values: number[] = [];
  subscription!: Subscription;

  constructor(public coldService: ColdstreamService) { }
  ngOnInit(): void {
    setTimeout(() => {
      this.subscription = this.coldService.emitValue().subscribe(data => {
        this.values.push(data);
      })
    },10000)

  }
  ngOnDestory() {
    console.log('component has been destroyed')
    this.subscription.unsubscribe()
  }


}

import { Component, OnInit } from '@angular/core';
import { Subscription } from 'rxjs';
import { ColdstreamService } from './coldstream.service';

@Component({
  selector: 'app-cstreamsub2',
  templateUrl: './cstreamsub2.component.html',
  styles: [
  ]
})
export class Cstreamsub2Component implements OnInit {
  values: number[] = [];
  subscription!: Subscription;

  constructor(public coldService: ColdstreamService) { }
  ngOnInit(): void {
    setTimeout(() => {
      this.subscription = this.coldService.emitValue().subscribe(data => {
        this.values.push(data);
      })
    },10000)

  }
  ngOnDestory() {
    console.log('component has been destroyed')
    this.subscription.unsubscribe()
  }


}
<h1>Subscriber-2</h1>
<ul>
    <li *ngFor="let i of values">
        {{i}}
    </li>
</ul>
.........................................................................................	
					Hot Stream

import { Injectable } from '@angular/core';
import { interval, Observable } from 'rxjs';
import { tap, map, share } from 'rxjs/operators';

@Injectable({
  providedIn: 'root'
})
export class HotstreamService {

  hotStream!: Observable<number>;
  
  constructor() {
    //emit value in 1s
    const source = interval(1000);
    //log side effect, emit result
    const stream = source.pipe(
      tap(() => console.log('***starts***')),
      map(i => i * 2),
      share()
    );
    //make it hot.
    //share observable among subscribers
    this.hotStream = stream.pipe(share());
  }
  public emitValue(): Observable<number> {
      return this.hotStream;
  }


}
<h1>Hot Subscriber-1</h1>
<ul>
    <li *ngFor="let i of values">
        {{i}}
    </li>
</ul>
import { Component, OnInit } from '@angular/core';
import { Subscription } from 'rxjs';
import { HotstreamService } from './hotstream.service';

@Component({
  selector: 'app-hotstreamsub1',
  templateUrl: './hotstreamsub1.component.html',
  styles: [
  ]
})
export class Hotstreamsub1Component implements OnInit {
  subscription!: Subscription;
  values: number[] = [];

  constructor(private hotStream:HotstreamService) { }

  ngOnInit(): void {
    this.subscription = this.hotStream.emitValue().subscribe(data => {
      this.values.push(data);
    })

  }
  ngOnDestory() {
    console.log('component has been destroyed')
    this.subscription.unsubscribe()
  }

}

<h1>Hot Subscriber-2</h1>
<ul>
    <li *ngFor="let i of values">
        {{i}}
    </li>
</ul>

import { Component, OnInit } from '@angular/core';
import { Subscription } from 'rxjs';
import { HotstreamService } from './hotstream.service';

@Component({
  selector: 'app-hotstreamsub2',
  templateUrl: './hotstreamsub2.component.html',
  styles: [
  ]
})
export class Hotstreamsub2Component implements OnInit {
  subscription!: Subscription;
  values: number[] = [];

  constructor(private hotStream: HotstreamService) { }

  ngOnInit(): void {
    setTimeout(() => {
      this.subscription = this.hotStream.emitValue().subscribe(data => {
        console.log(data)
        this.values.push(data);
      })
    }, 10000);

  }
  ngOnDestory() {
    console.log('component has been destroyed')
    this.subscription.unsubscribe()
  }

}
..........................................................................................
Subject:

What is a Subject?  :create the hot observable from scratch
  
 In RxJS Subject is a special type of Observable that allows values to be multicasted to many Observers.

While plain Observables are unicast (each subscribed Observer owns an independent execution of the Observable), Subjects are multicast.

"each subscribed Observer owns an independent execution of the Observable"
   =>Every Subscribers has its own independent copy of the Object.
   lets say 10 subscribers, 10 Observable copy is maintained.

"A Subject is a special type of Observable which shares a single execution path among observers"

"You can think of this as a single speaker talking at a microphone in a room full of people. Their message (the subject) is being delivered to many (multicast) people (the observers) at once. This is the basis of multicasting. Typical observables would be comparable to a 1 on 1 conversation".

There are 4 variants of subjects:

1.Subject - No initial value or replay behavior.
2.AsyncSubject - Emits latest value to observers upon completion.
3.BehaviorSubject - Requires an initial value and emits its current value (last emitted item) to new subscribers.
4.ReplaySubject - Emits specified number of last emitted values (a replay) to new subscribers.
...........................................................................................

import { Injectable } from "@angular/core";
import { BehaviorSubject } from "rxjs";


@Injectable({
    providedIn: 'root'
})
export class SubjectService {

    private behaviour = new BehaviorSubject(10);
    constructor() { }

    public broadCast(): BehaviorSubject<number> {
      return this.behaviour;
    }

}

import { Component, OnInit } from '@angular/core';
import { SubjectService } from './subject.service';

@Component({
  selector: 'app-subjectone',
  templateUrl: './subjectone.component.html',
  styles: [
  ]
})
export class SubjectoneComponent implements OnInit {
  
  value!: number;
  constructor(private subject: SubjectService) { }

  ngOnInit(): void {
    this.subject.broadCast().subscribe((data) => {
      this.value = data;
    });
  }
  public emitValue() {
    this.subject.broadCast().next(400)
  }

}

<h1>Subject-1 => {{value}}</h1>
<button (click)="emitValue()">BroadCast To All Component</button>
import { Component, OnInit } from '@angular/core';
import { SubjectService } from './subject.service';

@Component({
  selector: 'app-subjecttwo',
  templateUrl: './subjecttwo.component.html',
  styles: [
  ]
})
export class SubjecttwoComponent implements OnInit {
   value!: number;
  constructor(private subject: SubjectService) { }

  ngOnInit(): void {
    this.subject.broadCast().subscribe((data) => {
      this.value = data;
    });
  }
}

<h1>Subject-2 => {{value}}</h1>
..............................................................................................					HTTP Programming
.............................................................................................



import { HttpClient } from "@angular/common/http";
import { Injectable } from "@angular/core";
import { Observable } from "rxjs";
import { User } from "../types/user.type";



@Injectable({
    providedIn: 'root'
})
export class UserService {
    constructor(private http: HttpClient) { }

    public findAll(): Observable<User[]> {
        const url = 'http://localhost:3000/users';
        return this.http.get<User[]>(url)
    }

}
import { Component, OnInit } from '@angular/core';
import { Observable } from 'rxjs';
import { User } from '../types/user.type';
import { UserService } from './user.service';

@Component({
  selector: 'app-user',
  templateUrl: './user.component.html',
  styles: [
  ]
})
export class UserComponent implements OnInit {

  users!: Observable<User[]>

  constructor(private userService: UserService) { }

  ngOnInit(): void {
    this.users = this.userService.findAll();
  }

}
<div>
    <div *ngFor="let user of users |async">
        <h2>Id : {{user?.id ?? 0}}</h2>
        <h2>Name : {{user?.name ?? "name"}}</h2>
        <h2>User Name : {{user?.username ?? "username"}}</h2>
        <h2>Email : {{user?.email ?? "email"}}</h2>
    </div>
</div>
..............................................................................................

.............................................................................................
				HTTP Communication
............................................................................................

in order to make http calls with rest api servers,js offers an object called "XMLHTTPRequest"

But frameworks provide abstraction over XHR object.

Angular provides XHR Abstraction - @angular/common/http

Angular XHR is powered with Reactive -  XHR + REACTIVE - XHR +Streaming


HTTP MOdule:

common/http :

HttpClientModule :
  This is moudle having all http related apis

This HttpClientModule must be injected before interacting with http end points

HttpClientModule is injected into shared module in general


Steps:
ng g m httpprogramming --module=app


import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';



@NgModule({
  declarations: [],
  imports: [
    CommonModule
  ]
})
export class HttpprogrammingModule { }


............................

Back end setup:
..............
create json server 
start server

import { HttpClient } from '@angular/common/http';
import { Injectable } from '@angular/core';
import { Observable } from 'rxjs';
import { User } from '../types/user.type';

@Injectable({
  providedIn: 'root'
})
export class UserService {

  constructor(private http: HttpClient) { }

  //service api
  public findAll(): Observable<User[]> {
    const url = 'http://localhost:3000/users';
    return this.http.get<User[]>(url).pipe();
  }

}
import { Component, OnInit } from '@angular/core';
import { User } from '../types/user.type';
import { UserService } from './user.service';

@Component({
  selector: 'app-user',
  templateUrl: './user.component.html',
  styles: [
  ]
})
export class UserComponent implements OnInit {

  users!: Array<User>;
  constructor(private userService: UserService) { }

  ngOnInit(): void {
    this.userService.findAll().subscribe(users => {
      this.users = users;
    });
  }

}
<div>
    <h1>Users</h1>
    <ul>
        <li *ngFor="let user of users">
            <span>{{user.id}} {{user.name}}</span>
        </li>
    </ul>
</div>
............................................................................................
				 Error handling,resilence,add other api

import { HttpClient } from '@angular/common/http';
import { Injectable } from '@angular/core';
import { Observable, of } from 'rxjs';
import { catchError, retry, tap } from 'rxjs/operators';
import { User } from '../types/user.type';
import { environment } from 'src/environments/environment';

@Injectable({
  providedIn: 'root'
})
export class UserService {

  constructor(private http: HttpClient) { }

  //service api
  public findAll(): Observable<User[]> {

    const url = `${environment.url}/users`;
    return this.http.get<User[]>(url).pipe(
      retry(5),
      // catchError(() => of<User[]>([{ id: 0, name: 'foo' }])
      catchError(this.handleError<User[]>('findAll-users', this.fallback()))
    );
  }
  private fallback() {
    return [{ id: 0, name: 'foo' }];
  }

  findById(id: number): Observable<User> {
    const url = `${environment.url}/users/${id}`;
    return this.http.get<User>(url).pipe(
      tap(() => console.log(`fetched user id = ${id}`)),
      catchError(this.handleError<User>(`findByid id=${id}`))
    )
  }
  //generic error handler
  private handleError<T>(operation = "operation", result?: T) {
    return (error: any): Observable<T> => {
      //console.error(error);
      return of(result as T);
    }
  }
}
import { Component, OnInit } from '@angular/core';
import { Observable } from 'rxjs';
import { User } from '../types/user.type';
import { UserService } from './user.service';

@Component({
  selector: 'app-user',
  templateUrl: './user.component.html',
  styles: [
  ]
})
export class UserComponent implements OnInit {

  users!: Array<User>;
  user!: Observable<User>;
  constructor(private userService: UserService) { }

  ngOnInit(): void {
    this.userService.findAll().subscribe(users => {
      this.users = users;
    });
  }
  showUserByid() {
    this.user = this.userService.findById(13);
  }

}
<div>
    <h1>Users</h1>
    <ul>
        <li *ngFor="let user of users">
            <span>{{user.id}} {{user.name}}</span>
        </li>
    </ul>

</div>
<div>
    <button (click)="showUserByid()">Show User by Id</button>
    <h1>User By Id</h1>
    <h2>{{user  | async | json}}</h2>
</div>

UPDATE,REMOVE,DELETE: SAMPLE code :

save(post: Post) {
        const httpOptions = {
            headers: new HttpHeaders({
                'Content-Type': 'application/json'
            })
        }
        return this.http.post<Post>(this.url, post, httpOptions)
            .pipe(tap(() => console.log(`added Post`)),
                catchError(this.handleError<Post>('save Post'))
            )
    }
    remove(id: number): Observable<Post> {
        const httpOptions = {
            headers: new HttpHeaders({
                'Content-Type': 'application/json'
            })
        }
        const url = `http://localhost:3000/posts/${id}`;
        return this.http.delete<Post>(url, httpOptions)
            .pipe(tap(() => console.log(`deleted Post ${id}`)),
                catchError(this.handleError<Post>('delete Post'))
            )
    }
    update(id:number,post: Post):Observable<Post> {
        console.log('service update method')
        const url = `http://localhost:3000/posts/${id}`;

        const httpOptions = {
            headers: new HttpHeaders({
                'Content-Type': 'application/json'
            })
        }
        return this.http.put<Post>(url, post, httpOptions)
            .pipe(tap(() => console.log(`updated Post ${post.id}`)),
                catchError(this.handleError<any>('update Post'))
            )
    }
..............................................................................................
				  Routing: Single Page Web app
.............................................................................................

.............................................................................................
				 Routing
............................................................................................
What is routing?
 Navigation between pages.

Routing is implemented in web apps via links - hyper links.

HTML 5 offers hyper links through which we can navigate from one page to another page.

HTML offers an address to which we will be redirected- URL,URI.

Types of navigation

1.static  - html
2.dynamic  - via server side programs

In 2008, html 5 introduced dynamic navigation inside browser via javascript api called history which is object contains apis related for navigation.
  This is brith of single page web apps.

single page web apps(spa) contains one physical page we call landing page - home page

How to create single page Application?

SPAs use AJAX and HTML5 to create fluid and responsive Web apps, without constant page reloads. However, this means much of the work happens on the client side, in JavaScript.

SPA Stack:

javascript
HTML 5
CSS 3

Frameworks and SPA :

 Every client side js frameworks today offers spa implementation.
 Angular provides a spa implemenation via "@angualr/routing" project.

Routing Core Concepts:

1.URL Patterns

http://www.mydomain.com/index.html - static url
http://www.mydomain.com/contactus.pdf -static url
http://www.mydomain.com/login.aspx / login.jsp /login.php  - dynamic content url

http://www.mydomain.com/api/users/comments  -  Resource based url - REST API


Spa url patterns: hashbang url pattern

http://www.mydomain.com/index.html#contactus
http://www.mydomain.com/index.html#products
http://www.mydomain.com/index.html#profiles

spa simple syntax : here landing page and # symbol not req.which is implict.
http://www.mydomain.com/profiles

2.URLs AND page

 Every url is mapped with Component which display content of page.

///////////////////////////////////////////////////////////////////////////////////////////

Core Concepts and Objects in Routing :

1.RouterModule
2.Route[]
  An array of Route objects that define the navigation paths for the application.

import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';
import { HomeComponent } from './home.component';

//mapping component with url

/home ===> render HomeComponent
/abc  ===> render RenderComponent

const routes: Routes = [
  {
    path: 'home', component: HomeComponent
  },
 {
    path: 'abc', component: AbcComponent
  }
];

@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule]
})
export class AppRoutingModule { }

3.RouterLink

  Hyperlinks are defined <a href="home">home</a>

  <a routerLink="home">home</a>
  <a [routerLink]="home">home</a>

4.RouterOutlet
  Acts as a placeholder that Angular dynamically fills based on the current router state.

..............................................................................................
				Modularzation and Routing
.............................................................................................

Angular Apps are highly modular.

Modules are based on features

profiles is one module

admin is another module

payment is another module

............................................................................................

Path Mapping:

1.static path
   /home /admin /heroes /products    
	path:'home' path:'heroes' 
2.dynamic  path
    /heroes/1  /heores/100
    path:'heroes/:id'
3.homepath
   /  path: ''
4.nopath
  /xxx
   path:'**'

default Path

http://www.example.com/  http://localhost:4200/ 

when ever we enter this in browser , angular looks path:''
 
....................................................................................

Path Redirection:
 
if angular finds a particular url, if you want to redirect to some other url

  eg:

 if you type

  /foo =======> /bar

 {path:'/foo' ,redirectTo:'/bar'
  pathMatch: 'full' -Take full url pattern

..............................................................................................

Dynamic routing:

  /hero/:id

.............................................................................................
		 How to access Route Information during Navigation
...........................................................................................


Lets assume you are moving from http://localhost:4200/superheroes  to  /superhero/11


How to read 11(route parameter) inside component?

ActivatedRoute:
Provides access to information about a route associated with a component that is loaded in an outlet. Use to traverse the RouterState tree and extract information from nodes.

............................................................................................
			How to move from one page to another page


1.hyper links  <a routerLink="/home">

2.via Code : Programetic navigation : 

Router:
A service that provides navigation among views and URL manipulation capabilities.

http://localhost:4200/superhero/11

back buttonLogic with extra data supplied via url:

http://localhost:4200/superheroes;id=11;foo=foo
.............................................................................................
				Lazy Loading
............................................................................................

Angular app is collectionof many js files. if you sent the whole app to the browser it may take time.
Lazy loading is concept through which we can break application into smaller js , on demand only we can send js files.

  {
    path: 'admin',
    loadChildren: () => import('./admin/admin.module').then(m => m.AdminModule),
    canLoad: [AuthGuard]
  }

loadChildren: property tells angular to break the admin.module javascript to be loaded on demand

............................................................................................
				Nested Routing
.............................................................................................

Menu
  |
   submenu
   submenu

Single Path

{path:'category' , component:CagetoryComponent}

{path:'category' , 
 children: [
   {path:'books' ,component:Books}
 ]
}

/category/books - url pattern
............................................................................................
			Auth Gurad : Authentication based Routing
............................................................................................

Who can access which url and which component

{path: 'admin',component:AdminComponent, canActivate: [AuthGuard],}

here canActivate property result only decide whether AdminComponent to be rendered or not.

AuthGuard here is simple service which has to return boolean value "true/false"

.............................................................................................
			 Mulitple RouterOutlet in a Page
.............................................................................................

http://localhost:4200/admin(popup:compose)
http://localhost:4200/admin/crises(popup:compose)
http://localhost:4200/admin/heroes(popup:compose)


closePopup() {
    // Providing a `null` value to the named outlet
    // clears the contents of the named outlet
    this.router.navigate([{ outlets: { popup: null }}]);
  }

<div class="wrapper">
  <h1 class="title">Angular Router</h1>
  <nav>
    <a routerLink="/crisis-center" routerLinkActive="active">Crisis Center</a>
    <a routerLink="/superheroes" routerLinkActive="active">Heroes</a>
    <a routerLink="/admin" routerLinkActive="active">Admin</a>
    <a routerLink="/login" routerLinkActive="active">Login</a>
    <a [routerLink]="[{ outlets: { popup: ['compose'] } }]">Contact</a>
  </nav>
  <div [@routeAnimation]="getAnimationData(routerOutlet)">
    <router-outlet #routerOutlet="outlet"></router-outlet>
  </div>
  <router-outlet name="popup"></router-outlet>
</div>


